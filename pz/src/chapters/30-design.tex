\chapter{ПРОЕКТИРОВАНИЕ СИСТЕМЫ АВТОМАТИЗАЦИИ УПРАВЛЕНИЯ ЖИЗНЕННЫМ ЦИКЛОМ ВЕБ-СЕРВИСА}
\label{cha:design}

\section{Анализ требований к системе}

Так как полученный для равёртки веб-сервисе базируется на Node.js и исходный код разбит на библиотеки, то то для корректной
работы системы потребуется наличие регистров Node пакетов.
Помимо регистра пакетов необходимым будет регистр Docker образов, поскольку веб-сервис уже представлен в виде Docker образов
и имеет все необходимые образы ПО необходимые окружению.

Согласно требованиям были сформулированы основные действующими лица (актёры) в работе системы:
\begin{itemize}
    \item администратор --- пользователь занимающийся настройкой прав доступа другим пользователям
        и конфигурацией развёртки веб-сервиса,
    \item разработчик --- пользователь системы имеющий доступ к репозиториям с исходным кодом,
        хранилищам пакетов и контейнеров, а так же управлению релизами веб-сервиса,
    \item сотрудник отдела качества (тестировщик) --- пользователь системы имеющий доступ к просмотру аналитеческих данных и
        проведению автоматизированных тестовых сценариев внутри заранее подготовленных окружений.
\end{itemize}

Пользователь системы подразумевает любого актёра.
На основании описания актёров и их основных возможностей была составлена диаграмма случаев использования.
Изображение данной диаграммы представлено на Рисунке \ref{fig:use-cases}.

\begin{figure}[h!]
    \centering
    \begin{tikzpicture}
        \begin{umlsystem}[x=5]{system}{Система}
            \umlusecase[width=3cm]{Управление правами доступа}
            \umlusecase[y=-4, width=3cm]{Управление развёрткой}
            \umlusecase[x=6, y=-2, width=3cm]{Конфигурация окружений}
            \umlusecase[x=6, y=-6, width=3cm]{Конфигурация системных ограничений}

            \umlusecase[y=-8, width=3cm]{Получение доступа к исходному коду и хранилищам}
            \umlusecase[y=-12, width=3cm]{Управление релизами}

            \umlusecase[x=6, y=-14, width=3cm]{Проведение автоматизированного тестирования}
            \umlusecase[y=-16, width=3cm]{Сбор аналитических данных}
        \end{umlsystem}

        \umlactor[y=-2]{Администратор}{admin}
        \umlactor[y=-10]{Разработчик}{developer}
        \umlactor[y=-14]{Тестировщик}{qa}

        \umlassoc{admin}{usecase-1}
        \umlassoc{admin}{usecase-2}
        \umlassoc{developer}{usecase-5}
        \umlassoc{developer}{usecase-6}
        \umlassoc{qa}{usecase-7}
        \umlassoc{qa}{usecase-8}

        \umlinclude{usecase-3}{usecase-2}
        \umlinclude{usecase-4}{usecase-2}
    \end{tikzpicture}
    \caption{Диаграмма случаев использования системы}
    \label{fig:use-cases}
\end{figure}

С точки зрения CI/CD взаимодействие пользователя с системой сосредоточено вокруг комита в репозиторий и автоматическим запуском
одной или нескольких задач (Jobs) внутри определённой линии (Pipeline).
Каждая задача является набором последовательно исполняемых инструкций ожидаемо завершённых без ошибок.
В случае ошибки выполнение всей линии завершается и повторяется только по действию пользователя.
При этом линии задач строятся динамически в зависимости от конкретного репозитория и ветки, поэтому некоторые задачи могут быть пропущены при выполнении,
а некоторые комиты оставаться без линий задач вовсе.
В общем виде поведение системы отражено на Рисунке \ref{fig:system-common}.

\begin{figure}[h!]
    \centering
    \begin{tikzpicture}
        \begin{umlseqdiag}
            \umlactor[class=А]{Пользователь}{a}
            \umldatabase[class=B]{Репозиторий}{b}
            \umlobject[class=C]{Pipeline}{c}
            \umlobject[class=D]{Jobs}{d}
            \begin{umlcall}[op=коммит, type=asynchron]{a}{b}
                \begin{umlcall}[op=запускает, type=asynchron]{b}{c}
                    \begin{umlcall}[op=выполняет, type=synchron, return=0]{c}{d}
                    \end{umlcall}
                    \begin{umlcall}[op=пропущена, type=synchron]{c}{d}
                    \end{umlcall}
                    \begin{umlcall}[op=выполняет, type=synchron, return=1]{c}{d}
                    \end{umlcall}
                    \begin{umlcall}[op=пропущена, type=synchron]{c}{d}
                    \end{umlcall}
                \end{umlcall}
            \end{umlcall}
            \begin{umlcall}[op=коммит, type=asynchron]{a}{b}
            \end{umlcall}
            \begin{umlcall}[op=коммит, type=asynchron]{a}{b}
            \end{umlcall}
            \begin{umlcall}[op=коммит, type=asynchron]{a}{b}
                \begin{umlcall}[op=запускает, type=asynchron]{b}{c}
                    \begin{umlcall}[op=выполняет, type=synchron, return=0]{c}{d}
                    \end{umlcall}
                    \begin{umlcall}[op=пропущена, type=synchron]{c}{d}
                    \end{umlcall}
                    \begin{umlcall}[op=выполняет, type=synchron, return=0]{c}{d}
                    \end{umlcall}
                    \begin{umlcall}[op=выполняет, type=synchron, return=0]{c}{d}
                    \end{umlcall}
                \end{umlcall}
            \end{umlcall}
        \end{umlseqdiag}
    \end{tikzpicture}
    \caption{Общий случай работы системы}
    \label{fig:system-common}
\end{figure}

\section{Выбор сервисов архитекутры}

Проводя обзор доступных на рынке git хостингов, можно сделать вывод, что наиболее распространенным git хостингом на сегодняшний день является хостинг компании GitLab Inc.
К тому же, по соотношению цена-функционал хостинг этой компании существенно обходит конкурентов.
Также, к существенному преимуществу можно отнести наличие обширного сообщества пользователей и разработчиков программных решений на основе git хостинга GitLab,
что позволяет иметь доступ к множеству готовых решений и получать помощь в разработке при необходимости.

Для реализации поставленной в данной работе задачи гибкость настройки всей инфраструктуры окружения не требуется, а также ставится в приоритет скорость ввода в рабочее состояние.
Поэтому в качестве оркестратора вместо гибкости Kubernetes был выбран Docker Swarm.
Но так как в данной работе делаеся акцент на гибкость всей системы, то далее будет рассмотрена описание конфигурации для использования с Kubernetes, не считая уставноку и настройку самого кластера.
Для работы будет подготовлена одна вершина Docker Swarm в статусе мэнеджер, поскольку более не требуется на данном этапе.

Как было сказано ранее, для развёртки в работе используется Docker, поэтому необходим простой инструмент удалённого доступа к сокету Docker сервиса на рабочем сервере.
Для этих целей будет использоваться GitLab Runner с установленным исполнителем задач Docker.
Кратко описать работу ранера можно следующим образом: раннер запускается в отдельном контейнере с добавленным volume на сокет Docker,
таким образом получается избежать достаточно сложного и нелесообразного запуска Docker внутри Docker,
так как в этом случае раннер получает доступ напрямую к сокету Docker сервера.
Данное решение имеет потенциальную проблему с безопасностью, поскольку если злоумышленник получит доступ к описанию задач GitLab CI/CD, то он сможет запускать на рабочем сервере любое ПО.
Для избежания данной проблемы будут установлены настройки доступа внутри GitLab.
Так же для избежания потери полезного времени работы ранера, необходимо будет произвести настройку кэша ранера.
Ключевой настройкой явлется политика загрузки образов для задач, поскольку по умолчанию ранер в любом случае будет загружать образ из регистра, даже если образ представлен локально.
Согласно требованиям ранер должен будет запускать минимум три задачи за единицу времени, данное значение будет отражено в конфигурации на этапе реализации.

С его помощью автоматизация процессов развёртки и тестирования производится в декларативном стиле путём описания YAML файлов.

\section{Выбор модели ветвления}

Автоматизация контроля качества будет реализована путём запуска описанных разработчиками тестовых сценариев внутри Pipelines.
Отчёты по прохождению сценариев будут представлены в веб интерфейсе GitLab путём интеграции с CI/CD.

Для контроля версий будет использована модель ветвления git flow со следующими окружениями:

\begin{itemize}
    \item develop --- инсценировка рабочего окружения веб серсива для разработчиков,
    \item testing --- окружение для проведения ручного тестирования,
    \item release --- рабочее окружение сервиса для реальных пользователей.
\end{itemize}

Основная проблема заключается в обновлении пакетов зависимостей проекта, поскольку для обновления необходимо пройти засимимым сервисам и построить граф.
Для решения этой проблемы будет разработано программное решение на базе CI/CD c применением bash скриптов при помощи package.json файлов веб сервиса.

\begin{itemize}
    \item lint --- осуществление контроля качества изменений путём проверки семантических правил написания кода,
    \item test --- осуществление контроля качества путёт запуска описанных разработчиками тестов кода,
    \item build --- импортированная из репозитория common задача для сборки Docker образа и загрузки в регистр,
    \item publish --- импортированная из репозитория common задача для оповещения кластера о загрузке новой версии (опциональная задача, требует подтверждения пользователем).
\end{itemize}

\section{Составление плана тестирования}

Для проведения тесирования был составлен план содержащий набор ключевых функция для тестирвоания.
\begin{center}
    \begin{longtable}{|p{0.15\textwidth}|p{0.2\textwidth}|p{0.2\textwidth}|p{0.2\textwidth}|}
        \caption{План тестирования}
        \label{tab:testing-plan}
        \hline
        Название теста & Тестовый сценарий & Тестовые данные & Ожидаемый результат \\
        \hline
        Релиз новой версии в develop окружении & Открыть список коммитов ветки develop, выбрать необходимый для создания новой версии коммит, нажать кнопку релиза новой версии  & нет & Релиз успешно создаётся \\
        \hline
        Релиз новой версии в testing окружении & Открыть список коммитов ветки develop, произвести слияение веток develop в ветку testing  & нет & Релиз успешно создаётся \\
        \hline
        Релиз новой версии в release окружении & Открыть список коммитов ветки testing, произвести слияение веток testing в ветку release  & нет & Релиз успешно создаётся \\
        \hline
    \end{longtable}
\end{center}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "rpz"
%%% End:
