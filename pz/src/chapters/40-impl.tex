\chapter{Технологический раздел}
\label{cha:impl}

В данном разделе описано изготовление и требование всячины. Кстати,
в Latex нужно эскейпить подчёркивание (писать <<\verb|some\_function|>> для \Code{some\_function}).

\ifPDFTeX
Для вставки кода есть пакет \Code{listings}. К сожалению, пакет \Code{listings} всё ещё
работает криво при появлении в листинге русских букв и кодировке исходников utf-8.
В данном примере он (увы) на лету конвертируется в koi-8 в ходе сборки pdf.

Есть альтернатива \Code{listingsutf8}, однако она работает лишь с
\Code{\textbackslash{}lstinputlisting}, но не с окружением \Code{\textbackslash{}lstlisting}

Вот так можно вставлять псевдокод (питоноподобный язык определен в \Code{listings.inc.tex}):

\begin{lstlisting}[style=pseudocode,caption={Алгоритм оценки дипломных работ}]
def EvaluateDiplomas():
    for each student in Masters:
        student.Mark := 5
    for each student in Engineers:
        if Good(student):
            student.Mark := 5
        else:
            student.Mark := 4
\end{lstlisting}

Еще в шаблоне определен псевдоязык для BNF:

\begin{lstlisting}[style=grammar,basicstyle=\small,caption={Грамматика}]
  ifstmt -> "if" "(" expression ")" stmt |
            "if" "(" expression ")" stmt1 "else" stmt2
  number -> digit digit*
\end{lstlisting}

В листинге~\ref{lst:sample01} работают русские буквы. Сильная магия. Однако, работает
только во включаемых файлах, прямо в \TeX{} нельзя.

% Обратите внимание, что включается не ../src/..., а inc/src/...
% В Makefile есть соответствующее правило для inc/src/*,
% которое копирует исходные файлы из ../src и конвертирует из UTF-8 в KOI8-R.
% Кстати, поэтому использовать можно только русские буквы и ASCII,
% весь остальной UTF-8 вроде CJK и египетских иероглифов -- нельзя.

\lstinputlisting[language=C,caption=Пример (\Code{test.c}),label=lst:sample01]{listings/test.c}

\else

Для вставки кода есть пакет \texttt{minted}. Он хорош всем кроме: необходимости Python (есть во всех нормальных (нет, Windows, я не про тебя) ОС) и Pygments и того, что нормально работает лишь в \XeLaTeX.

Можно пользоваться расширенным BFN:

\begin{listing}[H]
    \begin{ebnfcode}
        letter = "A" | "B" | "C" | "D" | "E" | "F" | "G"
        | "H" | "I" | "J" | "K" | "L" | "M" | "N"
        | "O" | "P" | "Q" | "R" | "S" | "T" | "U"
        | "V" | "W" | "X" | "Y" | "Z" ;
        digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
        symbol = "[" | "]" | "{" | "}" | "(" | ")" | "<" | ">"
        | "'" | '"' | "=" | "|" | "." | "," | ";" ;
        character = letter | digit | symbol | "_" ;

        identifier = letter , { letter | digit | "_" } ;
        terminal = "'" , character , { character } , "'"
        | '"' , character , { character } , '"' ;

        lhs = identifier ;
        rhs = identifier
        | terminal
        | "[" , rhs , "]"
        | "{" , rhs , "}"
        | "(" , rhs , ")"
        | rhs , "|" , rhs
        | rhs , "," , rhs ;

        rule = lhs , "=" , rhs , ";" ;
        grammar = { rule } ;
    \end{ebnfcode}
    \caption{EBNF определённый через EBNF}
    \label{lst:ebnf}
\end{listing}

А вот в листинге \ref{lst:c} на языке C работают русские комменты. Спасибо Pygments и Minted за это.

\begin{listing}[H]
    \cfile{inc/src/test.c}
    \caption{Пример — test.c}
\end{listing}
\label{lst:c}

\fi

% Для вставки реального кода лучше использовать \texttt{\textbackslash lstinputlisting} (который понимает
% UTF8) и стили \Code{realcode} либо \Code{simplecode} (в зависимости от размера куска).




Можно также использовать окружение \Code{verbatim}, если \Code{listings} чем-то не
устраивает. Только следует помнить, что табы в нём <<съедаются>>. Существует так же команда \Code{\textbackslash{}verbatiminput} для вставки файла.

\begin{verbatim}
a_b = a + b; // русский комментарий
if (a_b > 0)
    a_b = 0;
\end{verbatim}

Перед реализацией необходимо произвести базовую настройку окружения.
Для этого был зарегистрирован GitLab аккаунт, установле SSH ключ и создана группа проекта.

Следующим этапом было произведено создание необходимых репозиториев с последующей загрузкой исходного кода предоставленного для работы веб-сервиса:

\begin{itemize}
    \item web-client --- репозиторий для хранения исходного кода веб-клиента проекта,
    \item api --- репозиторий для хранения исходного кода API проекта.
    \item node packages --- репозиторий для хранения исходного кода общих npm зависимостей проекта.
\end{itemize}

Так же в корне каждого репозитория был загружен Dockerfile для развёртки данного сервиса.
Так как в качестве модели ветвления была выбрана модель git flow, то так же были подговлены соответствующие ветки в репозиториях под разные окружения: develop, testing и release.
Установка доступа к данным репозиториям предоставляется только соответсвующим разработчикам данных программных решений в целях безопасности.

На следующем этапе был подготовлен репозиторий deployment для хранения общих скриптов и конфигураций окружения и развёртки.
Установка доступа к этому репозиторию предоставляется только команде обеспечения развёртки в целях безопасности.

Подготвка хранилищ npm пакетов и Docker образов не требуется, так как GitLab берёт на себя данную отвественность и не требует дополнительных действий от пользователя.

Базовая подготовка окружения завершена.
Следующим этапом был установлен и настроен Docker Swarm кластер.
Одной и ключевой настройкой является открытие портов на уровне операционной системы сервера:

\begin{itemize}
    \item TCP порт 2377 для коммуникации между менеджерами кластера,
    \item TCP и UDP порты 7946 для взаимодействия между нодами кластера,
    \item UDP порта 4789 для управления сетевым трафиком.
\end{itemize}

Дальше была произведена инициализация кластера на сервера.
В данном этапе нет необходимости при использовании Kubernetes.

После была произведена установка и настройка GitLab Runner на рабочем сервере.
В качестве дистрибутива на этапе проектирования был выбран Docker, как самый быстрый и удобный.
После установки необходимо зарегистрировать GitLab Runner, для этого на странице настроек CI/CD группы в GitLab был получен регистрационный токен.
Конфигурация runner производится путём редактирования config.toml файла в соответствии с этапом проектирования, основными настройками являются являются:

\begin{itemize}
    \item Установка executor --- docker executor,
    \item Установка volumes --- /var/run/docker.sock,
    \item Установка pull-policy --- if-not-present,
    \item Установка concurrent --- 3.
\end{itemize}

На данном этапе runner полностью готов к работе и ожидает входящих задач.

На следующем этапе необходимо подготовить общие для работы сервисов конфигурации запуска, которые будут храниться в репозитории deployment:

\begin{itemize}
    \item build.yaml --- набор универсальных задач, предназначенный для сборки Docker образа и последующей загрузки в  регистр контейнеров,
    \item publish.yaml --- набор универсальных задач, предназначенный для оповещения кластера о об обонвлении сервиса для загрузки новой версии,
    \item publish-api.yaml --- расширенная версия publish.yaml, содержащая дополнительные задачи для проведения миграция базы данных в случае необходимости,
    \item build-package.yaml --- набор задач для для отслеживания к какому конкретному сервису принадлежит npm пакет путём построения графа зависимостей на основании package.json файлов,
    \item publish-package.yaml --- набор задач для загрузки собранного npm пакета .
\end{itemize}

Далее была произведена конфигурация на уровне сервисов компонентов, в репозитории api и web-client были добавлены конфигурации CI/CD путёт создания .gitlab-ci.yml файла, содержащего следующие задачи:
\begin{itemize}
    \item lint --- осуществление контроля качества изменений путём проверки семантических правил написания кода,
    \item test --- осуществление контроля качества путёт запуска описанных разработчиками тестов кода,
    \item build --- импортированная из репозитория common задача для сборки Docker образа и загрузки в регистр,
    \item publish --- импортированная из репозитория common задача для оповещения кластера о загрузке новой версии (опциональная задача, требует подтверждения пользователем).
\end{itemize}

Аналогичные задачи были описаны для репозитория node packages.

Завершающим этапом реализации является описание конфигурационных файлов Docker Swarm.
Для этого в настройках CI/CD репозитория deployment были добавлены переменные окружения (секреты) на все рабочие окружния (develop, testing и release),
содержащие аргументы сервисов компонентов системы (доступы к базе данных, секрет ключа авторизации и так далее).
Аналогично были добавлены Docker Swarm конфигурационные файлы под каждый окружения:

\begin{itemize}
    \item develop --- каждый сервис запускается на сервере в одном экзмепляре, ресурсы сервера сильно ограничены во избежание лишней нагрузки,
    \item testing --- аналогичен develop, только используется для целей ручного тестирования веб-сервиса,
    \item release --- web-client запускается в одном экзмепляре, база данных и api запускаются в трёх, большая часть ресурса отведена под эти сервисы.
\end{itemize}

Так же был подготовлен пример описания аналогичных файлов при использовании с Kubernetes.

Основная часть работы сделана полном объёме, дальше было произведено ручное тестирование функций программного комплекса согласно плану тестирования, составленному на этапе проектирования.
В ходе тестирования все компоненты системы работали исправно и тесты ошибок не выявили.

Итоговая стоимость разработки с учётом только стоимости использования сервисов и обсулживания составляет 0 рублей за установку и 0 рублей в месяц за обслуживание.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "rpz"
%%% End:
